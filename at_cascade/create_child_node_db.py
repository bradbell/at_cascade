# -----------------------------------------------------------------------------
# at_cascade: Cascading Dismod_at Analysis From Parent To Child Regions
#           Copyright (C) 2021-21 University of Washington
#              (Bradley M. Bell bradbell@uw.edu)
#
# This program is distributed under the terms of the
#     GNU Affero General Public License version 3.0 or later
# see http://www.gnu.org/licenses/agpl.txt
# -----------------------------------------------------------------------------
'''
{xsrst_begin create_child_node_db}

Create Child Database From Fit in Parent Database
#################################################

Syntax
******
{xsrst_file
    # BEGIN syntax
    # END syntax
}

all_node_database
*****************
is a python string containing the name of the :ref:`all_node_db`.
This argument can't be ``None``.

parent_node_database
********************
is a python string containing the name of a :ref:`glossary.fit_node_database`
that has the results of a dismod_at sample command for both the fixed
and random effects.
It also has the results of a predict command using the sample table
generated by the sample command and the avgint table corresponding to
:ref:`create_child_avgint`.
The predict and sample tables
are used to create priors in the child not databases.

parent_node
===========
We use *parent_node* to refer to the parent node in the
dismod_at option table in the *parent_node_database*.

child_node_databases
********************
is a python dictionary and if *child_name* is a key for *child_node_databases*,
*child_name* is a :ref:`glossary.node_name` and a child of the *parent_node*.
The value *child_node_databases[child_name]* is the name of
a *fit_node_database* that is created by this command.
In this database, *child_name* will be the parent node in
the dismod_at option table.
This database will only have the dismod_at input tables.
The value priors for the variables in the model will be constructed using
the samples in the *parent_node_database*.
Other priors will be the same as in the *parent_node_database*

{xsrst_end create_child_node_db}
'''
# ----------------------------------------------------------------------------
def table_name2id(table, col_name, row_name) :
    for (row_id, row) in enumerate(table) :
        if row[col_name] == row_name :
            return row_id
    assert False
# ----------------------------------------------------------------------------
def add_number_to_row_name(tbl_name, table) :
    column_name = tbl_name + '_name'
    row_id      = len(table) - 1
    row_name    = table[row_id][column_name]
    row_name   += '_' + str(row_id)
    table[row_id][column_name] = row_name
# ----------------------------------------------------------------------------
def create_child_node_db(
# BEGIN syntax
# at_cascade.create_child_node_db(
    all_node_database    = None ,
    parent_node_database = None ,
    child_node_databases = None ,
# )
# END syntax
) :
    # ------------------------------------------------------------------------
    import copy
    import shutil
    import statistics
    import dismod_at
    # ------------------------------------------------------------------------
    # covariate_reference_table
    new        = False
    connection = dismod_at.create_connection(all_node_database, new)
    covariate_reference_table = dismod_at.get_table_dict(
        connection, 'covariate_reference'
    )
    connection.close()
    #
    # parent_tables
    new           = False
    connection    = dismod_at.create_connection(parent_node_database, new)
    parent_tables = dict()
    for name in [
        'avgint',
        'covariate',
        'density',
        'fit_var',
        'integrand',
        'mulcov',
        'node',
        'option',
        'prior',
        'predict',
        'rate',
        'sample',
        'smooth',
        'smooth_grid',
        'var',
    ] :
        parent_tables[name] = dismod_at.get_table_dict(connection, name)
    connection.close()
    #
    # name_rate2integrand
    name_rate2integrand = {
        'iota'  : 'Sincidence',
        'rho'   : 'remission',
        'chi'   : 'mtexcess',
    }
    # parent_sample
    parent_sample = dict()
    for predict_row in parent_tables['predict'] :
        avgint_id          = predict_row['avgint_id']
        avgint_row         = parent_tables['avgint'][avgint_id]
        integrand_id       = avgint_row['integrand_id']
        age_id             = avgint_row['c_age_id']
        time_id            = avgint_row['c_time_id']
        key                = (integrand_id, age_id, time_id)
        if not key in parent_sample :
            parent_sample[key] = list()
        parent_sample[key].append( predict_row['avg_integrand'] )
    #
    # parent_node_name
    parent_node_name = None
    for row in parent_tables['option'] :
        assert row['option_name'] != 'parent_node_id'
        if row['option_name'] == 'parent_node_name' :
            parent_node_name = row['option_value']
    assert parent_node_name is not None
    #
    # node_table
    node_table = parent_tables['node']
    #
    # parent_node_id
    parent_node_id = table_name2id(node_table, 'node_name', parent_node_name)
    #
    # gaussian_density_id
    table              = parent_tables['density']
    gaussian_density_id = table_name2id(table, 'density_name', 'gaussian')
    #
    for child_name in child_node_databases :
        # ---------------------------------------------------------------------
        # create child_node_databases[child_name]
        # ---------------------------------------------------------------------
        #
        # child_node_id
        child_node_id = table_name2id(node_table, 'node_name', child_name)
        assert node_table[child_node_id]['parent'] == parent_node_id
        #
        # child_node_database = parent_node_database
        child_database = child_node_databases[child_name]
        shutil.copyfile(parent_node_database, child_database)
        #
        # child_connection
        new        = False
        child_connection = dismod_at.create_connection(child_database, new)
        #
        # child_option_table
        child_option_table = copy.deepcopy(parent_tables['option'])
        for row in child_option_table :
            if row['option_name'] == 'parent_node_name' :
                row['option_value'] = child_name
        tbl_name = 'option'
        dismod_at.replace_table(child_connection, tbl_name, child_option_table)
        #
        # child_covariate_table
        child_covariate_table = copy.deepcopy(parent_tables['covariate'])
        for child_row in child_covariate_table :
            child_row['reference'] = None
        for row in covariate_reference_table :
            if row['node_id'] == child_node_id :
                covariate_id           = row['covariate_id']
                child_row              = child_covariate_table[covariate_id]
                child_row['reference'] = row['reference']
        for child_row in child_covariate_table :
            assert not child_row['reference'] is None
        #
        # --------------------------------------------------------------------
        # initilaize child smooth and smooth_grid tables as empty
        child_smooth_table      = list()
        child_smooth_grid_table = list()
        #
        # initialize child_prior_table
        child_prior_table = copy.deepcopy( parent_tables['prior'] )
        # --------------------------------------------------------------------
        # child_mulcov_table
        # and corresponding entries in the following child tables:
        # smooth, smooth_grid, and prior
        child_mulcov_table = copy.deepcopy( parent_tables['mulcov'] )
        for (mulcov_id, child_mulcov_row) in enumerate(child_mulcov_table) :
            assert child_mulcov_row['subgroup_smooth_id'] is None
            parent_smooth_id = child_mulcov_row['group_smooth_id']
            if not parent_smooth_id is None :
                #
                # integrand_id
                name         = 'mulcov_' + str(mulcov_id)
                table        = parent_tables['integrand']
                integrand_id = table_name2id(table, 'integrand_name', name)
                #
                smooth_row = parent_tables['smooth'][parent_smooth_id]
                smooth_row = copy.copy(smooth_row)
                #
                # update: child_smooth_table
                assert smooth_row['mulstd_value_prior_id'] is None
                assert smooth_row['mulstd_dage_prior_id']  is None
                assert smooth_row['mulstd_dtime_prior_id'] is None
                child_smooth_id = len(child_smooth_table)
                child_smooth_table.append(smooth_row)
                #
                # change child_mulcov_table to use the new smoothing
                child_mulcov_row['group_smooth_id'] = child_smooth_id
                #
                # add rows for this smoothing to child_smooth_grid_table
                for parent_grid_row in parent_tables['smooth_grid'] :
                    if parent_grid_row['smooth_id'] == parent_smooth_id :
                        #
                        # parent_prior_row
                        prior_id         = parent_grid_row['value_prior_id']
                        parent_prior_row = parent_tables['prior'][prior_id]
                        #
                        # key
                        age_id    = parent_grid_row['age_id']
                        time_id   = parent_grid_row['time_id']
                        key       = (integrand_id, age_id, time_id)
                        #
                        #
                        mean = statistics.mean(parent_sample[key])
                        std  = statistics.stdev(parent_sample[key])
                        #
                        # update: child_prior_table, child_prior_id
                        child_prior_row         = copy.copy( parent_prior_row )
                        child_prior_row['mean'] = mean
                        child_prior_row['std']  = std
                        child_prior_row['density_id'] = gaussian_density_id
                        child_prior_id = len(child_prior_table)
                        child_prior_table.append( child_prior_row )
                        add_number_to_row_name('prior', child_prior_table)
                        #
                        # update: child_smooth_grid_table
                        child_grid_row = copy.copy( parent_grid_row )
                        child_grid_row['value_prior_id'] = child_prior_id
                        child_grid_row['smooth_id']      = child_smooth_id
                        child_smooth_grid_table.append( child_grid_row )
        # --------------------------------------------------------------------
        # child_rate_table
        # and corresponding entries in the following child tables:
        # smooth, smooth_grid, and prior
        child_rate_table = copy.deepcopy( parent_tables['rate'] )
        for child_rate_row in child_rate_table :
            rate_name        = child_rate_row['rate_name']
            #
            # parent_smooth_id
            parent_smooth_id = None
            if rate_name in name_rate2integrand :
                assert child_rate_row['child_nslist_id'] is None
                parent_smooth_id = child_rate_row['parent_smooth_id']
            if not parent_smooth_id is None :
                #
                # integrand_id
                integrand_name  = name_rate2integrand[rate_name]
                integrand_table = parent_tables['integrand']
                integrand_id = table_name2id(
                    integrand_table, 'integrand_name', integrand_name
                )
                #
                smooth_row = parent_tables['smooth'][parent_smooth_id]
                smooth_row = copy.copy(smooth_row)
                #
                assert smooth_row['mulstd_value_prior_id'] is None
                assert smooth_row['mulstd_dage_prior_id']  is None
                assert smooth_row['mulstd_dtime_prior_id'] is None
                #
                # update: child_smooth_table for case where its is the parent
                child_smooth_id = len(child_smooth_table)
                child_smooth_table.append(smooth_row)
                #
                #
                # change child_rate_table to use the new smoothing
                child_rate_row['parent_smooth_id'] = child_smooth_id
                #
                # add rows for this smoothing to child_smooth_grid_table
                for parent_grid_row in parent_tables['smooth_grid'] :
                    if parent_grid_row['smooth_id'] == parent_smooth_id :
                        #
                        # parent_prior_row
                        prior_id         = parent_grid_row['value_prior_id']
                        parent_prior_row = parent_tables['prior'][prior_id]
                        #
                        # key
                        age_id    = parent_grid_row['age_id']
                        time_id   = parent_grid_row['time_id']
                        key       = (integrand_id, age_id, time_id)
                        #
                        #
                        mean = statistics.mean(parent_sample[key])
                        std  = statistics.stdev(parent_sample[key])
                        #
                        # update: child_prior_table, child_prior_id
                        child_prior_row         = copy.copy( parent_prior_row )
                        child_prior_row['mean'] = mean
                        child_prior_row['std']  = std
                        child_prior_row['density_id'] = gaussian_density_id
                        child_prior_id = len(child_prior_table)
                        child_prior_table.append( child_prior_row )
                        add_number_to_row_name('prior', child_prior_table)
                        #
                        # update: child_smooth_grid_table
                        child_grid_row = copy.copy( parent_grid_row )
                        child_grid_row['value_prior_id'] = child_prior_id
                        child_grid_row['smooth_id']      = child_smooth_id
                        child_smooth_grid_table.append( child_grid_row )
            #
            # parent_smooth_id
            parent_smooth_id = None
            if rate_name in name_rate2integrand :
                parent_smooth_id = child_rate_row['child_smooth_id']
            if not parent_smooth_id is None :
                #
                smooth_row = parent_tables['smooth'][parent_smooth_id]
                smooth_row = copy.copy(smooth_row)
                #
                assert smooth_row['mulstd_value_prior_id'] is None
                assert smooth_row['mulstd_dage_prior_id']  is None
                assert smooth_row['mulstd_dtime_prior_id'] is None
                #
                # update: child_smooth_table for case where its is the parent
                child_smooth_id = len(child_smooth_table)
                child_smooth_table.append(smooth_row)
                #
                # change child_rate_table to use the new smoothing
                child_rate_row['child_smooth_id'] = child_smooth_id
                #
                # add rows for this smoothing to child_smooth_grid_table
                for parent_grid_row in parent_tables['smooth_grid'] :
                    if parent_grid_row['smooth_id'] == parent_smooth_id :
                        #
                        # update: child_smooth_grid_table
                        child_grid_row = copy.copy( parent_grid_row )
                        child_grid_row['smooth_id']      = child_smooth_id
                        child_smooth_grid_table.append( child_grid_row )
        dismod_at.replace_table(
                child_connection, 'mulcov', child_mulcov_table
        )
        dismod_at.replace_table(
                child_connection, 'rate', child_rate_table
        )
        dismod_at.replace_table(
                child_connection, 'prior', child_prior_table
        )
        dismod_at.replace_table(
            child_connection, 'smooth', child_smooth_table
        )
        dismod_at.replace_table(
            child_connection, 'smooth_grid', child_smooth_grid_table
        )

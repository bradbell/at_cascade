# SPDX-License-Identifier: AGPL-3.0-or-later
# SPDX-FileCopyrightText: University of Washington <https://www.washington.edu>
# SPDX-FileContributor: 2021-22 Bradley M. Bell
# ----------------------------------------------------------------------------
import os
import math
import sys
import time
import shutil
# import at_cascade with a preference current directory version
current_directory = os.getcwd()
if os.path.isfile( current_directory + '/at_cascade/__init__.py' ) :
   sys.path.insert(0, current_directory)
import at_cascade
# --------------------------------------------------------------------------
'''
{xrst_begin csv_absolute_covariate}
{xrst_spell
   sim
   Sincidence
}

Example Simulating and Fitting an Incidence Shock Using Absolute Covariates
###########################################################################

Simulation
**********

shock_function
==============
The shock function is defined as one, if age is 50 and time is 2000,
and zero otherwise.

rate_truth
==========
All of the rates are zero except for iota which is

.. math::

      iota(age, time) = 0.01 \cdot \exp[ 2 * shock(age, time) ]

grid
====
The age grid is [ 0, 50, 100] and the time grid in [1980, 2000, 2020].

option_sim.csv
==============
The option_sim.csv defaults are used except for
:ref:`csv_simulate@Input Files@option_sim.csv@absolute_covariates`
which is set to the shock column in the covariate.csv file.
Note that
:ref:`csv_simulate@Input Files@option_sim.csv@covariate_effect_depend_age_time`
is false. This means that the measurement of prevalence at age and time
of the sock (age 50 and time 2000) use shock covariate value one.
This affects the value of iota (used to fit that prevalence point)
for all previous times.
One might like the effect on iota to use the shock covariate
previous values for previous times; i.e. to have the
*covariate_effect_depend_age_time* true, but this
would not agree with how dismod_at interprets the covariate value
(try it).


node.csv
========
There is only one node for this example and it is called n0.
This is the root node of the
:ref:`csv_simulate@Input Files@node.csv` table
so its *parent_name* is empty.

covariate.csv
=============
The of omega (zero) and the shock covariate are written
to this file with one row for each sex, and age-time grid point;
see :ref:`csv_simulate@Input Files@covariate.csv`  .

no_effect_rate.csv
==================
The no effect rates are zero except for iota which is 0.01

multiplier_sim.csv
==================
There is a multiplier with value 2.0 that multiplies the shock covariate
and affects the value of iota;
see :ref:`csv_simulate@Input Files@multiplier_sim.csv`  .

simulate.csv
============
Sincidence and prevalence are simulated for each sex and each age and time
in the grid;
see :ref:`csv_simulate@Input Files@simulate.csv`  .


Fit
***

option_fit.csv
==============
The option_fit.csv defaults are used except for
:ref:csv_fit@Input Files@option_fit.csv@absolute_covariates`
which is set to shock,
:ref:csv_fit@Input Files@option_fit.csv@refit_split`
which is set to false, and
:ref:csv_fit@Input Files@option_fit.csv@db2csv`
which is set to true.

fit_goal.csv
============
The only node we are fitting for this example is n0;
see :ref:`csv_fit@Input Files@fit_goal.csv`  .

predict_integrand.csv
=====================
The fit_predict.csv and sam_predict.csv files (generated by this example)
will contain the values of Sincidence and the covariate multiplier;
see :ref:`csv_fit@Input Files@predict_integrand.csv`  .

prior.csv
=========
The only prior defined for this example is a uniform with
mean 0, lower limit -4, and upper limit +4;
see :ref:`csv_fit@Input Files@prior.csv`  .

mulcov.csv
==========
The only covariate multiplier in the fit uses the shock covariate,
affects the rate iota,
and has the prior distribution mentioned above;
see :ref:`csv_fit@Input Files@mulcov.csv`  .

data_in.csv
===========
The measurements with out noise
:ref:`csv_simulate@Output Files@data_sim.csv@meas_mean` are used for the
simulated data.
Both Sincidence and prevalence are included, but the Sincidence data is
held out.
Thus the Sincidence residuals are a measure of how well iota was
estimated from prevalence.

Example Source Code
*******************
{xrst_literal
   BEGIN_PYTHON
   END_PYTHON
}


{xrst_end csv_absolute_covariate}
'''
# BEGIN_PYTHON
# --------------------------------------------------------------------------
#
# random_seed
random_seed = str( int( time.time() ) )
#
# age_grid, time_grid
age_grid  = list( range(0,105,50) )
time_grid = list( range(1980,2021,20) )
#
# shock_function
def shock_function(age, time) :
   assert 50 in age_grid
   assert 2000 in time_grid
   if age == 50 and time == 2000 :
      return 1
   return 0
#
# shock_multiplier
shock_multiplier = 2.0
#
# rate_truth
def rate_truth(rate_name, age, time) :
   if rate_name == 'omega' :
      return 0.00
   if rate_name == 'iota' :
      shock = shock_function(age, time)
      return math.exp( shock_multiplier * shock) * 0.01
   assert False
#
# ----------------------------------------------------------------------------
# simulation files
# ----------------------------------------------------------------------------
#
# sim_file
sim_file = dict()
#
# option_sim.csv
random_seed = str( int( time.time() ) )
sim_file['option_sim.csv'] = \
'''name,value
absolute_covariates,shock
covariate_effect_depend_age_time,false
'''
sim_file['option_sim.csv'] += f'random_seed,{random_seed}\n'
#
# node.csv
sim_file['node.csv'] = \
'''node_name,parent_name
n0,
'''
#
# covariate.csv
sim_file['covariate.csv'] = 'node_name,sex,age,time,omega,shock\n'
omega     = rate_truth('omega', 0, 0)
node_name = 'n0'
for sex in [ 'female', 'male' ] :
   for age in age_grid :
      for time in time_grid :
         shock = shock_function(age, time)
         row = f'{node_name},{sex},{age},{time},{omega},{shock}\n'
         sim_file['covariate.csv'] += row
#
# no_effect_rate.csv
assert shock_function(0, 0) == 0.0
iota = rate_truth('iota', 0, 0)
sim_file['no_effect_rate.csv'] = 'rate_name,age,time,rate_truth\n'
sim_file['no_effect_rate.csv'] += f'iota,0,0,{iota}\n'
#
# multiplier_sim.csv
data  = 'multiplier_id,rate_name,covariate_or_sex,multiplier_truth\n'
data += f'0,iota,shock,{shock_multiplier}'
sim_file['multiplier_sim.csv'] = data
#
# simulate.csv
header  = 'simulate_id,integrand_name,node_name,sex,age_lower,age_upper,'
header += 'time_lower,time_upper,percent_cv\n'
sim_file['simulate.csv'] = header
simulate_id     = -1
percent_cv      = 5.0
node_name       = 'n0'
for integrand_name  in [ 'Sincidence' , 'prevalence' ] :
   for sex in [ 'female', 'male' ] :
      for age in age_grid :
         for time in time_grid :
            simulate_id += 1
            row  = f'{simulate_id},{integrand_name},{node_name},{sex},'
            row += f'{age},{age},{time},{time},{percent_cv}\n'
            sim_file['simulate.csv'] += row
# ----------------------------------------------------------------------------
# fit files
# ----------------------------------------------------------------------------
#
# fit_file
fit_file = dict()
#
# option_fit.csv
fit_file['option_fit.csv']  =  \
'''name,value
absolute_covariates,shock
refit_split,false
db2csv,true
'''
fit_file['option_fit.csv'] += f'random_seed,{random_seed}\n'
#
# fit_goal.csv
fit_file['fit_goal.csv'] = \
'''node_name
n0
'''
#
# predict_integrand.csv
fit_file['predict_integrand.csv'] = \
'''integrand_name
Sincidence
mulcov_0
'''
#
# prior.csv
fit_file['prior.csv'] = \
'''name,density,mean,std,eta,lower,upper
uniform_-4_+4,uniform,0.0,,,-4,+4
'''
#
# child_rate.csv
fit_file['child_rate.csv'] = \
'''rate_name,value_prior
'''
#
# mulcov.csv
fit_file['mulcov.csv'] = \
'''covariate,type,effected,value_prior,const_value
shock,rate_value,iota,uniform_-4_+4,
'''
#
# -----------------------------------------------------------------------------
# sim
def sim(sim_dir) :
   #
   # write input csv files
   for name in sim_file :
      file_name = f'{sim_dir}/{name}'
      file_ptr  = open(file_name, 'w')
      file_ptr.write( sim_file[name] )
      file_ptr.close()
   #
   # csv.simulate
   at_cascade.csv.simulate(sim_dir)
   #
   # data_join.csv
   at_cascade.csv.join_file(
      left_file   = f'{sim_dir}/simulate.csv' ,
      right_file  = f'{sim_dir}/data_sim.csv' ,
      result_file = f'{sim_dir}/data_join.csv'     ,
   )
# -----------------------------------------------------------------------------
# fit
def fit(sim_dir, fit_dir) :
   #
   # node.csv, covarite.csv
   for file_name in [ 'node.csv', 'covariate.csv' ] :
      shutil.copyfile(
         src = f'{sim_dir}/{file_name}' ,
         dst = f'{fit_dir}/{file_name}' ,
      )
   #
   # fit_file['parent_rate.csv']
   assert shock_function(0, 0) == 0
   iota  = rate_truth('iota', 0, 0)
   data  = 'rate_name,age,time,value_prior,dage_prior,dtime_prior,const_value\n'
   data  += f'iota,0.0,0.0,,,,{iota}\n'
   fit_file['parent_rate.csv'] = data
   #
   # csv files in fit_file
   for name in fit_file :
      file_name = f'{fit_dir}/{name}'
      file_ptr  = open(file_name, 'w')
      file_ptr.write( fit_file[name] )
      file_ptr.close()
   #
   # data_join_table
   # This is a join of simulate.csv and dats_sim.csv
   data_join_table = at_cascade.csv.read_table(
      file_name = f'{sim_dir}/data_join.csv'
   )
   #
   # data_in.csv
   table = list()
   for row_join in data_join_table :
      #
      # row_in
      row_in = dict()
      copy_list  = [ 'integrand_name', 'node_name', 'sex' ]
      copy_list += [ 'age_lower', 'age_upper', 'time_lower', 'time_upper' ]
      row_in['data_id']   = row_join['simulate_id']
      row_in['integrand'] = row_join['integrand_name']
      for key in copy_list :
         row_in[key] = row_join[key]
      row_in['meas_value'] = row_join['meas_mean']
      row_in['meas_std']   = 1e-3
      if row_join['integrand_name'] == 'Sincidence' :
         row_in['hold_out']   = '1'
      else :
         assert row_join['integrand_name'] == 'prevalence'
         row_in['hold_out']   = '0'
      #
      table.append( row_in )
   at_cascade.csv.write_table(
         file_name = f'{fit_dir}/data_in.csv' ,
         table     = table ,
   )
   #
   # fit
   at_cascade.csv.fit(fit_dir)
   #
   # fit_predict.csv
   # check predictions for the multiplier
   fit_predict_table = at_cascade.csv.read_table(
      file_name = f'{fit_dir}/fit_predict.csv'
   )
   for row in fit_predict_table :
      integrand_name = row['integrand_name']
      avg_integrand  = float( row['avg_integrand'] )
      if integrand_name == 'mulcov_0' :
         truth = shock_multiplier
         relative_error  = avg_integrand / shock_multiplier - 1.0
         if abs(relative_error) >= 1e-2 :
            print('relative_error = ', relative_error)
         assert abs(relative_error) < 1e-2
   #
   # dismod_at data_table.csv
   # check that shock is an absolute covariate (reference has not changed).
   data_table = at_cascade.csv.read_table(
      file_name = f'{fit_dir}/n0/data.csv'
   )
   for row in data_table :
      assert row['age_lo']  == row['age_up']
      assert row['time_lo'] == row['time_up']
      age   = float( row['age_lo'] )
      time  = float( row['time_lo'] )
      shock = float( row['shock'] )
      assert shock == shock_function(age, time)

# -----------------------------------------------------------------------------
# Without this, the mac will try to execute main on each processor.
if __name__ == '__main__' :
   #
   # sim_dir
   sim_dir = 'build/example/csv/sim'
   if not os.path.exists(sim_dir) :
      os.makedirs(sim_dir)
   #
   # clear out a previous run
   if os.path.exists( 'build/example/csv/fit/n0' ) :
      shutil.rmtree( 'build/example/csv/fit/n0' )
   #
   # fit_dir
   fit_dir = 'build/example/csv/fit'
   if not os.path.exists(fit_dir) :
      os.mkdir(fit_dir)
   #
   # sim
   sim(sim_dir)
   #
   # fit
   fit(sim_dir, fit_dir)
   #
   print('csv_absolute_covariate: OK')
   sys.exit(0)
# END_PYTHON
